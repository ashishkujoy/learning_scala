package com.thoughtworks.dataStructure
import com.thoughtworks.BaseTest
import com.thoughtworks.dataStructure.MyStream.startsWith

class MyStreamTest extends BaseTest {

  test("should convert a given empty stream to empty list") {
    MyStream.empty.toList shouldBe List.empty
  }

  test("should convert a given stream to a list") {
    val stream = MyStream(1, 2, 3, 4)
    val list   = List(1, 2, 3, 4)
    stream.toList shouldBe list
  }

  test("should take n elements of a stream") {
    MyStream(1, 2, 3, 4).take(2).toList shouldBe MyStream(1, 2).toList
  }

  test("should take all elements of a stream given when size of stream is less then elements required") {
    MyStream(1, 2, 3, 4).take(20).toList shouldBe MyStream(1, 2, 3, 4).toList
  }

  test("take of empty stream should give empty stream") {
    MyStream.empty.take(2).toList shouldBe MyStream.empty.toList
  }

  test("should give empty stream if element to be taken are negative") {
    MyStream(1, 2, 3, 4).take(-20).toList shouldBe MyStream.empty.toList
  }

  test("should give take elements of stream till they satisfy given predicate") {
    MyStream(1, 2, 3, 4, 5).takeWhile(_ < 4).toList shouldBe MyStream(1, 2, 3).toList
    MyStream(1, 2, 3, 4).takeWhile_1(_ < 3).toList shouldBe MyStream(1, 2).toList
  }

  test("should give empty stream for takeWhile on empty stream") {
    MyStream.empty[Int].takeWhile(_ < 4).toList shouldBe MyStream.empty[Int].toList
  }

  test("should fold stream starting with given default value") {
    MyStream(1, 2, 3).foldRight("")((a, b) => s"$a _ $b") shouldBe "1 _ 2 _ 3 _ "
  }

  test("should give true if a stream contain given element") {
    MyStream(1, 2, 3, 4).exists(_ == 3) shouldBe true
  }

  test("should give false if any element doesn't conform to given predicate") {
    MyStream(1, 2, 3, 4).forAll(_ < 3) shouldBe false
  }

  test("should map all element of stream as per given mapper") {
    MyStream(1, 2, 3, 4).map(_ + 1).toList shouldBe MyStream(2, 3, 4, 5).toList
  }

  test("should filter element of a stream as per given predicate") {
    MyStream(1, 2, 3, 4).filter(_ % 2 == 0).toList shouldBe MyStream(2, 4).toList
  }

  test("should concat two streams") {
    MyStream(1, 2).concat(MyStream(3, 4)).toList shouldBe List(1, 2, 3, 4)
  }

  test("should flatten the stream generated by given mapper") {
    MyStream(1, 2).flatMap(a => MyStream(a, a + 1)).toList shouldBe List(1, 2, 2, 3)
  }

  test("should create a stream of given element") {
    MyStream.constant(2).take(4).toList shouldBe List(2, 2, 2, 2)
  }

  test("should create a stream of incremental integers") {
    MyStream.from(2).take(4).toList shouldBe List(2, 3, 4, 5)
  }

  test("should create a stream of fibonacci series") {
    MyStream.fibonacci.take(6).toList shouldBe List(0, 1, 1, 2, 3, 5)
  }

  test("should create a stream from given default value as per given function") {
    val myStream = MyStream.unfold(0)(a => if (a < 5) Some(a + 1, a + 1) else None)
    myStream.toList shouldBe List(1, 2, 3, 4, 5)
  }

  test("should give head of a stream") {
    MyStream(1, 2, 3).head shouldBe 1
  }

  test("should throw exception for head of empty stream") {
    val exception = intercept[Exception] {
      MyStream.empty[Int].head
    }

    exception.getMessage shouldBe "Head of empty MyStream"
  }

  test("should give tail of a stream") {
    MyStream(1, 2, 3, 4).tail.toList shouldBe List(2, 3, 4)
  }

  test("should throw exception for tail of empty stream") {
    val exception = intercept[Exception] {
      MyStream.empty[Int].tail
    }

    exception.getMessage shouldBe "Tail of empty MyStream"
  }

  test("should give stream consist of tuple of given streams") {
    MyStream(1, 2, 3).zip(MyStream('a', 'b', 'c')).toList shouldBe List((1, 'a'), (2, 'b'), (3, 'c'))
  }

  test("should zip stream of different sizes") {
    MyStream(1, 2, 3).zip(MyStream('a', 'b')).toList shouldBe List((1, 'a'), (2, 'b'))
    MyStream(1, 2, 3).zip(MyStream('a', 'b', 'c', 'd')).toList shouldBe List((1, 'a'), (2, 'b'), (3, 'c'))
  }

  test("should zip given streams as per given function") {
    def isEven(numb: Int): Boolean = numb % 2 == 0
    MyStream(1, 2, 3).zipWith(MyStream(1, 2, 3))((a, b) => isEven(a + b)).toList shouldBe List(true, true, true)
  }

  test("should give true if any element of stream satisfy given condition") {
    MyStream(1, 2, 3, 4).exists(_ == 4) shouldBe true
  }

  test("should give false if no element of stream satisfy given condition") {
    MyStream(1, 2, 3, 4).exists(_ == 5) shouldBe false
  }

  test("should give true if all element of stream satisfy given condition") {
    MyStream(1, 2, 3, 4).forAll(_ < 5) shouldBe true
  }

  test("should give false if all element of stream does not satisfy given condition") {
    MyStream(1, 2, 3, 4).forAll(_ < 4) shouldBe false
  }

  test("should give true for stream starting with itself") {
    val stream = MyStream(1, 2, 3)
    startsWith(stream, stream) shouldBe true
  }

  test("should give true if a stream starts with a another given stream") {
    val stream    = MyStream(1, 2, 3)
    val subStream = MyStream(1, 2)
    startsWith(stream, subStream) shouldBe true
  }

  test("should give false if a given stream doesn't starts with another given stream") {
    val stream        = MyStream(1, 2, 3)
    val anotherStream = MyStream(4, 5)
    startsWith(stream, anotherStream) shouldBe false
  }

  test("should give false for a sub-stream to start with super stream") {
    val stream    = MyStream(1, 2, 3, 4)
    val subStream = MyStream(1, 2)
    startsWith(subStream, stream) shouldBe false
  }

}
